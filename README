Modified and Simplified Algorithm:


Let us say there are 5 nodes : A, B, C, D, E
Topology :
{
A : [ B, C ]
B : [ A, D ]
C : [ A, D ]
D : [ B, C ]
E : [ D ]
}

Each machine program initializes its view if topology with its neighbors in config

E.g. for A let us say its neighbors are B and C. It initializes as follows :

A:
  {
    A: { nodes : [ unknown ], num : 2 } (number of neighbors in that in config which is known)
    B: { nodes : [ unknown ], num : -1 } (-1 means unknown)
    E: [ nodes : [ unknown ], num : -1 } (-1 means unknown)
  }

After B and C, connects it sends  their info it will fill in the info we can update
A:
  {
    A: [ B, C ], 2 (resolved)
    B: [ A ], 2 (1 left)
    C: [ A ], 1 (1 left)

  }

Convergence :

1. A node should stop sending to its peer when all his neighbors are found
So in case of "A, above map should be reached before "A" decides to stop sending even if "B" and "C" are unresolved.
"A" is fully resolved so it can stop after sending that once to its neighbors.

2. A node should stop receiving when its state is resolved and we have key for each node in the topology tree and all members are
resolved.
So e.g. in above example "A" should wait for information "C" and "D" and keep receiving
So when A reached following state (where we have everything resolved at each entry and we have keys for all nodes
A:
  {
    A: [ B, C ], 2
    B: [ A, D ], 2
    C: [ A, D ], 2
    D:  [ B, C ], 2
    E:  [ D ] , 1

  }